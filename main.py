import json
import requests
import time
import os
import yaml
import sys

def load_config(path):
    f = open(path, 'r', encoding='utf-8')
    ystr = f.read()
    ymllist = yaml.load(ystr, Loader=yaml.FullLoader)
    return ymllist

# Load configuration either from file or command line arguments
if os.path.exists('config.yml'):
    c = load_config('config.yml')
    CLOUDFLARE_ZONE_ID = c['CLOUDFLARE_ZONE_ID']
    CLOUDFLARE_EMAIL = c['CLOUDFLARE_EMAIL']
    CLOUDFLARE_API_KEY = c['CLOUDFLARE_API_KEY']
    ABUSEIPDB_API_KEY = c['ABUSEIPDB_API_KEY']
else:
    # Verify we have all required command line arguments
    if len(sys.argv) < 5:
        print("Error: Missing required arguments")
        print("Usage: python main.py CLOUDFLARE_ZONE_ID CLOUDFLARE_EMAIL CLOUDFLARE_API_KEY ABUSEIPDB_API_KEY")
        sys.exit(1)
    CLOUDFLARE_ZONE_ID = sys.argv[1]
    CLOUDFLARE_EMAIL = sys.argv[2]
    CLOUDFLARE_API_KEY = sys.argv[3]
    ABUSEIPDB_API_KEY = sys.argv[4]

PAYLOAD = {
    "query": """query ListFirewallEvents($zoneTag: string, $filter: FirewallEventsAdaptiveFilter_InputObject) {
        viewer {
            zones(filter: { zoneTag: $zoneTag }) {
                firewallEventsAdaptive(
                    filter: $filter
                    limit: 1000
                    orderBy: [datetime_DESC]
                ) {
                    action
                    clientASNDescription
                    clientAsn
                    clientCountryName
                    clientIP
                    clientRequestHTTPHost
                    clientRequestHTTPMethodName
                    clientRequestHTTPProtocol
                    clientRequestPath
                    clientRequestQuery
                    datetime
                    rayName
                    ruleId
                    source
                    userAgent
                }
            }
        }
    }""",
    "variables": {
        "zoneTag": CLOUDFLARE_ZONE_ID,
        "filter": {
            "datetime_geq": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.localtime(time.time()-60*60*8-60*60*2.5)),
            "datetime_leq": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.localtime(time.time()-60*60*8)),
            "action": "block"  # Only get blocked IPs
        }
    }
}

PAYLOAD = json.dumps(PAYLOAD)
headers = {
    "Content-Type": "application/json",
    "X-Auth-Key": CLOUDFLARE_API_KEY,
    "X-Auth-Email": CLOUDFLARE_EMAIL
}

def get_blocked_ip(max_retries=3):
    for attempt in range(max_retries):
        try:
            r = requests.post("https://api.cloudflare.com/client/v4/graphql/",
                            headers=headers, data=PAYLOAD, timeout=30)
            r.raise_for_status()  # Raise an exception for bad status codes
            return r.json()
        except Exception as e:
            print(f"Attempt {attempt + 1}/{max_retries} failed: {str(e)}")
            if attempt == max_retries - 1:
                print("Max retries reached, giving up")
                return None
            time.sleep(2 ** attempt)  # Exponential backoff

def get_comment(it):
    return (f"The IP has triggered Cloudflare WAF. action: {it['action']} source: {it['source']} "
            f"clientAsn: {it['clientAsn']} clientASNDescription: {it['clientASNDescription']} "
            f"clientCountryName: {it['clientCountryName']} clientIP: {it['clientIP']} "
            f"clientRequestHTTPHost: {it['clientRequestHTTPHost']} "
            f"clientRequestHTTPMethodName: {it['clientRequestHTTPMethodName']} "
            f"clientRequestHTTPProtocol: {it['clientRequestHTTPProtocol']} "
            f"clientRequestPath: {it['clientRequestPath']} "
            f"clientRequestQuery: {it['clientRequestQuery']} datetime: {it['datetime']} "
            f"rayName: {it['rayName']} ruleId: {it['ruleId']} userAgent: {it['userAgent']}. "
            f"Report generated by Cloudflare-WAF-to-AbuseIPDB "
            f"(https://github.com/MHG-LAB/Cloudflare-WAF-to-AbuseIPDB).")

def report_bad_ip(it):
    try:
        url = 'https://api.abuseipdb.com/api/v2/report'
        params = {
            'ip': it['clientIP'],
            'categories': '9,13,14,15,16,19,20,21',
            'comment': get_comment(it)
        }
        headers = {
            'Accept': 'application/json',
            'Key': ABUSEIPDB_API_KEY
        }
        r = requests.post(url=url, headers=headers, params=params)
        if r.status_code == 200:
            print(f"Reported: {it['clientIP']}")
            response_data = r.json()
            print(json.dumps(response_data, sort_keys=True, indent=4))
            return True
        else:
            print(f"Error: HTTP {r.status_code}")
            return False
    except Exception as e:
        print(f"Error reporting IP: {str(e)}")
        return False

# List of rule IDs to exclude
excepted_ruleId = ["fa01280809254f82978e827892db4e46"]

def main():
    print("==================== Start ====================")
    print(f"Current time: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())}")
    print(f"Query time range: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()-60*60*8))}")
    
    response = get_blocked_ip()
    if not response:
        print("Failed to get blocked IPs")
        return

    if "data" not in response or "viewer" not in response["data"]:
        print("Invalid response format")
        return

    ip_bad_list = response["data"]["viewer"]["zones"][0]["firewallEventsAdaptive"]
    print(f"Total events found: {len(ip_bad_list)}")

    reported_ip_list = []
    for event in ip_bad_list:
        if (event['ruleId'] not in excepted_ruleId and 
            event['clientIP'] not in reported_ip_list):
            if report_bad_ip(event):
                reported_ip_list.append(event['clientIP'])

    print(f"Total unique IPs reported: {len(reported_ip_list)}")
    print("==================== End ====================")

if __name__ == "__main__":
    main()
