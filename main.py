import json
import requests
import time
import os
import yaml
import sys

def load_config(path):
    with open(path, 'r', encoding='utf-8') as f:
        ystr = f.read()
        ymllist = yaml.load(ystr, Loader=yaml.FullLoader)
        return ymllist

# Load configuration from file or environment variables
if os.path.exists('config.yml'):
    c = load_config('config.yml')
    CLOUDFLARE_ZONE_IDS = c['CLOUDFLARE_ZONE_IDS']
    CLOUDFLARE_EMAIL = c['CLOUDFLARE_EMAIL']
    CLOUDFLARE_API_KEY = c['CLOUDFLARE_API_KEY']
    ABUSEIPDB_API_KEY = c['ABUSEIPDB_API_KEY']
    WHITELISTED_IPS = c.get('WHITELISTED_IPS', "").split(",")
    DISCORD_WEBHOOK_URL = c.get('DISCORD_WEBHOOK_URL', '')
    REPORT_IPS = c.get('REPORT_IPS', 'true').lower() == 'true'
    SEND_DISCORD_WEBHOOK = c.get('SEND_DISCORD_WEBHOOK', 'true').lower() == 'true'
else:
    if len(sys.argv) < 6:
        print("Error: Missing required arguments")
        print("Usage: python main.py CLOUDFLARE_ZONE_IDS CLOUDFLARE_EMAIL CLOUDFLARE_API_KEY ABUSEIPDB_API_KEY WHITELISTED_IPS")
        sys.exit(1)
    CLOUDFLARE_ZONE_IDS = sys.argv[1].split(",")
    CLOUDFLARE_EMAIL = sys.argv[2]
    CLOUDFLARE_API_KEY = sys.argv[3]
    ABUSEIPDB_API_KEY = sys.argv[4]
    WHITELISTED_IPS = sys.argv[5].split(",")
    DISCORD_WEBHOOK_URL = os.getenv('DISCORD_WEBHOOK_URL', '')
    REPORT_IPS = True
    SEND_DISCORD_WEBHOOK = True

def get_blocked_ips(zone_id, max_retries=3):
    payload = {
        "query": """query ListFirewallEvents($zoneTag: string, $filter: FirewallEventsAdaptiveFilter_InputObject) {
            viewer {
                zones(filter: { zoneTag: $zoneTag }) {
                    firewallEventsAdaptive(
                        filter: $filter
                        limit: 1000
                        orderBy: [datetime_DESC]
                    ) {
                        action
                        clientASNDescription
                        clientAsn
                        clientCountryName
                        clientIP
                        clientRequestHTTPMethodName
                        clientRequestHTTPProtocol
                        clientRequestPath
                        clientRequestQuery
                        datetime
                        rayName
                        ruleId
                        source
                        userAgent
                    }
                }
            }
        }""",
        "variables": {
            "zoneTag": zone_id,
            "filter": {
                "datetime_geq": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.localtime(time.time() - 60*60*10.5)),
                "datetime_leq": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.localtime(time.time() - 60*60*8))
            }
        }
    }
    payload = json.dumps(payload)
    headers = {
        "Content-Type": "application/json",
        "X-Auth-Key": CLOUDFLARE_API_KEY,
        "X-Auth-Email": CLOUDFLARE_EMAIL
    }

    for attempt in range(max_retries):
        try:
            r = requests.post("https://api.cloudflare.com/client/v4/graphql/", headers=headers, data=payload, timeout=30)
            r.raise_for_status()
            return r.json()
        except Exception as e:
            print(f"Attempt {attempt + 1}/{max_retries} failed: {str(e)}")
            if attempt == max_retries - 1:
                print("Max retries reached, giving up")
                return None
            time.sleep(2 ** attempt) 

def get_comment(it):
    return (f"The IP has triggered Cloudflare WAF. action: {it['action']} source: {it['source']} "
            f"clientAsn: {it['clientAsn']} clientASNDescription: {it['clientASNDescription']} "
            f"clientCountryName: {it['clientCountryName']} clientIP: {it['clientIP']} "
            f"clientRequestHTTPMethodName: {it['clientRequestHTTPMethodName']} "
            f"clientRequestHTTPProtocol: {it['clientRequestHTTPProtocol']} "
            f"clientRequestPath: {it['clientRequestPath']} "
            f"clientRequestQuery: {it['clientRequestQuery']} datetime: {it['datetime']} "
            f"rayName: {it['rayName']} ruleId: {it['ruleId']} userAgent: {it['userAgent']}. "
            f"Report generated by Cloudflare-WAF-to-AbuseIPDB.(https://github.com/0123-smallbottle/Cloudflare-WAF-to-AbuseIPDB)")

def get_country_flag_emoji(country_code):
    return "".join([chr(ord(c) + 127397) for c in country_code.upper()])

def send_discord_notification(event, abuse_response=None):
    if not DISCORD_WEBHOOK_URL or not SEND_DISCORD_WEBHOOK:
        return

    country_flag = get_country_flag_emoji(event['clientCountryName'])
    
    fields = [
        {"name": "IP Address", "value": event['clientIP'], "inline": True},
        {"name": "Country", "value": f"{country_flag} {event['clientCountryName']}", "inline": True},
        {"name": "ASN", "value": f"{event['clientAsn']} ({event['clientASNDescription']})", "inline": False},
        {"name": "Action", "value": event['action'], "inline": True},
        {"name": "Source", "value": event['source'], "inline": True},
        {"name": "Method", "value": event['clientRequestHTTPMethodName'], "inline": True},
        {"name": "Path", "value": event['clientRequestPath'][:1024], "inline": False},
        {"name": "Query", "value": event['clientRequestQuery'][:1024], "inline": False},
        {"name": "User Agent", "value": event['userAgent'][:1024], "inline": False}
    ]

    if abuse_response and 'data' in abuse_response:
        report_data = abuse_response['data']
        fields.append({"name": "AbuseIPDB Report", "value": f"Report #{report_data.get('reportNumber')} - Confidence: {report_data.get('abuseConfidenceScore')}%", "inline": False})

    title = "WAF Event Reported to AbuseIPDB" if REPORT_IPS else "WAF Event Detected"
    embed = {
        "title": title,
        "color": 0xFF0000,
        "fields": fields,
        "timestamp": event['datetime']
    }

    payload = {
        "embeds": [embed]
    }

    try:
        requests.post(DISCORD_WEBHOOK_URL, json=payload)
    except Exception as e:
        print(f"Failed to send Discord notification: {str(e)}")

def report_bad_ip(it):
    if not REPORT_IPS:
        print(f"Skipping report for IP {it['clientIP']} (reporting disabled)")
        return None
        
    try:
        url = 'https://api.abuseipdb.com/api/v2/report'
        params = {
            'ip': it['clientIP'],
            'categories': '10,19',
            'comment': get_comment(it)
        }
        headers = {
            'Accept': 'application/json',
            'Key': ABUSEIPDB_API_KEY
        }
        r = requests.post(url=url, headers=headers, params=params)
        if r.status_code == 200:
            print(f"Reported: {it['clientIP']}")
            response_data = r.json()
            print(json.dumps(response_data, sort_keys=True, indent=4))
            return response_data
        else:
            print(f"Error: HTTP {r.status_code}")
            return None
    except Exception as e:
        print(f"Error reporting IP: {str(e)}")
        return None

def main():
    print("==================== Start ====================")
    print(f"Current time: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())}")
    print(f"Query time range: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time() - 60*60*8))}")
    
    reported_ip_list = []

    for zone_id in CLOUDFLARE_ZONE_IDS:
        print(f"Processing Zone ID: {zone_id}")
        response = get_blocked_ips(zone_id)
        if not response or "data" not in response or "viewer" not in response["data"]:
            print(f"Failed to get blocked IPs for Zone ID: {zone_id}")
            continue

        ip_bad_list = response["data"]["viewer"]["zones"][0]["firewallEventsAdaptive"]
        print(f"Total events found in Zone {zone_id}: {len(ip_bad_list)}")

        for event in ip_bad_list:
            if (event['clientIP'] not in reported_ip_list and 
                event['clientIP'] not in WHITELISTED_IPS):
                print(f"IP: {event['clientIP']}, Location: {event['clientCountryName']}, Time: {event['datetime']}, ASN: {event['clientAsn']}, ASN Description: {event['clientASNDescription']}")
                
                abuse_response = report_bad_ip(event)
                send_discord_notification(event, abuse_response)
                
                if REPORT_IPS and abuse_response:
                    reported_ip_list.append(event['clientIP'])

    print(f"Total unique IPs reported: {len(reported_ip_list)}")
    print("==================== End ====================")

def run_loop():
    while True:
        main()
        time.sleep(3600)

if __name__ == "__main__":
    run_loop()